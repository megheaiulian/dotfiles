set encoding=utf-8
scriptencoding utf-8
set shell=/bin/sh

augroup MyVimrc
  autocmd!
augroup END
command! -nargs=* AutoCmd autocmd MyVimrc <args>

let g:loaded_vimballPlugin = 1
let g:loaded_getscriptPlugin = 1
let g:loaded_rrhelper = 1
let g:did_install_default_menus = 1
let g:sh_noisk = 1
if exists('$TMUX')
  " tmux will only forward escape sequences to the terminal if surrounded by a DCS sequence
  let &t_SI .= "\<Esc>Ptmux;\<Esc>\<Esc>[6 q\<Esc>\\"
  let &t_SR .= "\<Esc>Ptmux;\<Esc>\<Esc>[4 q\<Esc>\\"
  let &t_EI .= "\<Esc>Ptmux;\<Esc>\<Esc>[2 q\<Esc>\\"
else
  let &t_SI .= "\<Esc>[6 q"
  let &t_SR .= "\<Esc>[4 q"
  let &t_EI .= "\<Esc>[2 q"
endif
set number
set shortmess+=I
set showmode
set mouse=a
set list listchars=tab:▸\ ,eol:¬,trail:~,space:·,extends:>,precedes:<,nbsp:⎵
set autoread
set noswapfile
set nobackup
set nowrap
set splitright
set splitbelow
set switchbuf=useopen,usetab
set wildmenu
set wildmode=longest:full,list:full
set previewheight=20
set complete=.,w,b,u,t,i,k
set omnifunc=syntaxcomplete#Complete
set completeopt=longest,menuone
set pumheight=15
set autoindent
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set smarttab
set shiftround
set showcmd
set hidden
set incsearch
set hlsearch|nohlsearch
set backspace=indent,eol,start
set sidescrolloff=5
set scrolloff=1
set nostartofline
if &startofline
  augroup vimrc_stayput
    autocmd!
    autocmd BufLeave * set nostartofline |
          \ autocmd vimrc_stayput CursorMoved,CursorMovedI * set startofline |
          \ autocmd! vimrc_stayput CursorMoved,CursorMovedI
  augroup END
endif
set sessionoptions-=options
set updatetime=750
set timeoutlen=1200
set ttimeoutlen=50
set lazyredraw
set ttyfast
" set clipboard^=unnamedplus,unnamed
function! AFTERLOAD()
  set statusline=%f\ %h%m%r%w
  set laststatus=2
  if exists('g:loaded_fugitive')
    set statusline+=%{fugitive#head()}
  endif
  set statusline+=%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)
endfunction
AutoCmd FileType * call AFTERLOAD()
command! StatusDebug set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v][%p%%]\ [LEN=%L]
command! StatusNormal call AFTERLOAD()
if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif
filetype plugin indent on

nnoremap <Esc><Esc> :nohlsearch<CR>

nnoremap ]] ]m
nnoremap [[ [m

if executable('rg')
  set grepprg=rg\ --vimgrep
elseif executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor\ --ignore-case\ --column
endif
set grepformat=%f:%l:%c:%m,%f:%l:%m

AutoCmd BufEnter,CursorHold,CursorHoldI,CursorMoved,CursorMovedI,FocusGained,BufEnter,FocusLost,WinLeave * checktime
AutoCmd BufEnter * syntax sync minlines=99999
AutoCmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line('$') | exe 'normal! g`"zz' | endif
AutoCmd CmdLineEnter * packadd cmdline-completion
AutoCmd BufNewFile,BufReadPre * packadd scalpel
AutoCmd BufNewFile,BufReadPre * packadd ferret
AutoCmd BufNewFile,BufReadPre * packadd vim-sneak
AutoCmd BufNewFile,BufReadPre * packadd vim-repeat
AutoCmd BufNewFile,BufReadPre * packadd vim-commentary
AutoCmd BufNewFile,BufReadPre * packadd vim-surround
AutoCmd BufNewFile,BufReadPre * packadd vim-fugitive

nnoremap <Esc><Esc> :nohlsearch<CR>
nnoremap j gj
nnoremap k gk
vnoremap > >gv
vnoremap < <gv
nnoremap <C-s> :update<CR>
inoremap <C-s> <Esc>:update<CR>
nnoremap <C-q> :bwipeout<CR>
nnoremap ,q :bdelete<CR>
nnoremap <silent><expr> <Space>x winnr('$') != 1 ? ':<C-u>close<CR>' : ""
xnoremap <C-s> <C-C>:<C-u>update<CR>
nnoremap <expr> 0 virtcol('.') - 1 <= indent('.') && col('.') > 1 ? '0' : '_'
nnoremap H ^
nnoremap L $
vnoremap L g_
nnoremap <silent> <Tab> :wincmd w<CR>
nnoremap <silent> <S-Tab> :wincmd W<CR>
nnoremap <silent> <C-Up> :resize -1<CR>
nnoremap <silent> <C-Down> :resize +1<CR>
nnoremap <silent> <C-Left> :vertical resize +1<CR>
nnoremap <silent> <C-Right> :vertical resize -1<CR>
vnoremap . :normal .<CR>
nnoremap ,w :set wrap!<cr>
nnoremap <Leader>w :%s/\s\+$//e<CR>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
inoremap <C-a> <Home>
inoremap <C-e> <End>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <Space><Space> :tabnew %<CR>
nnoremap <Space>q :tabclose<CR>
nnoremap n nzzzv
nnoremap N Nzzzv
vnoremap <Space>y "+
vnoremap <Space>p "+
nnoremap <Space>p "+
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
function! s:VSetSearch()
  let l:temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = l:temp
endfunction
vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR><c-o>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR><c-o>

map [1;5A <C-Up>
map [1;5B <C-Down>
map [1;5C <C-Left>
map [1;5D <C-Right>
map [1;2A <S-Up>
map [1;2B <S-Down>
map [1;2C <S-Right>
map [1;2D <S-Left>

command! RemoveTrailingSpaces %s/\s\+$

silent! colorscheme hybrid
" hi Comment cterm=italic
" let g:spacegray_use_italics = 1

let &t_ZH="\e[3m"
let &t_ZR="\e[23m"

let g:ale_sign_error = '→'
let g:ale_sign_warning = '→'
let g:ale_sign_info = 'i'
let g:ale_pattern_options_enabled = 1
let g:ale_fixers = {
      \ 'javascript': ['eslint'],
      \ 'html': ['eslint']
      \}
let g:ale_fix_on_save = 1
let g:ale_linters = {
      \ 'javascript': ['eslint'],
      \ 'html': ['eslint'],
      \}
let g:ale_linter_aliases = {
      \ 'html': 'javascript',
      \}
let g:sneak#label = 1
nmap s <Plug>SneakLabel_s
nmap S <Plug>SneakLabel_S

let g:netrw_banner=0
let g:netrw_liststyle = 3

let g:ScalpelCommand='S'

let g:Lf_ShortcutF = '<C-P>'
let g:Lf_ShortcutB = '<Bs>'
let g:Lf_WindowHeight = 0.20
let g:Lf_DefaultMode = 'FullPath'
let g:Lf_FollowLinks = 'yes'
nnoremap <Leader>m :LeaderfMru<CR>
nnoremap <Leader>h :LeaderfMruCwd<CR>
nnoremap <Leader>k :LeaderfHistoryCmd<CR>
